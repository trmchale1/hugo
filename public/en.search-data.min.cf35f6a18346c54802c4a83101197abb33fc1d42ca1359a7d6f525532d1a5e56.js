'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/abt_tim/','title':"About Tim",'section':"Docs",'content':"About Tim #  My story #  My name is Tim McHale. I started learning how to code back in 2014. I wanted to become a developer at the time, but instead worked other jobs in tech, like Data Analysis and Sales.\nLooking back at my github I see some early projects that got me excited about software, connecting to the Twitter API to search ISIS tweets (a hot story at the time), python algorithms to search genetic strings in the human genome. They look like misfit toys to me now. However, the coronavirus lockdown has given me some solitude, and perspective - this winter I am finishing the CS degree I started in 2014.\nThe purpose of the blog is to detail my journey with advanced computer science\u0026hellip;\n"});index.add({'id':1,'href':'/posts/firstblog/','title':"First Blog",'section':"Blog",'content':"This is a first blog. My plan is to write up go, python data structures and algorithms. Then explore web design patterns in those languages.\n"});index.add({'id':2,'href':'/docs/topic/go-data-structures/','title':"Go Data Structures",'section':"Topic",'content':"Go Data Structures #  Code and explanation of a Go data structure\n"});index.add({'id':3,'href':'/docs/topic/go-data-structures/queue/','title':"Queue",'section':"Go Data Structures",'content':"Go Data Structures #  Code and explanation of a Go data structure\nQueue #  First we look at the queue data structure. A queue is a simple list where we add to the back and remove from the front. Below is the class structure of the list in Go, creating a Node - when initiated keeps track of itâ€™s head, tail and the next element in the list.\n// Queue : holds 2 nodes type Queue struct { Head *Node Tail *Node } // Node : A Queue node type Node struct { Next *Node Data interface{} } // New : Create a new Queue func New() *Queue { emptyNode := \u0026amp;Node{ Next: nil, Data: nil, } return \u0026amp;Queue { Head: emptyNode, Tail: emptyNode, } } Enqueue and Dequeue #  Algorithms for popping off the front and adding to the back, using a linked list.\n// Appends to the end of the list func (q *Queue) Enqueue(d interface {}) *Queue { nextNode := \u0026amp;Node { Next: nil, Data: d, } if q.Head.Data == nil { q.Head = nextNode } else { q.Tail = nextNode } q.Tail = nextNode return q } func (q *Queue) Dequeue() *Queue { var node = q.Head q.Head = q.Head.Next return q }  Code  "});index.add({'id':4,'href':'/docs/topic/go-data-structures/stack/','title':"Stack",'section':"Go Data Structures",'content':"Go Data Structures #  Code and explanation for a Go Data Structure\nStack #  A stack is a fundamental data structure. It is used in the Operating System, memory is implemented as a stack. If we are able to visualize a stack, it will help us visualize some of the more complex ideas in computer science.\nBelow the Go class structure for a Stack.\ntype Stack struct { Head *Node int size = 0 } type Node struct { Next *Node Data interface{} } func New() *Stack { emptyNode := \u0026amp;Node{ Next: nil, Data: nil, } return \u0026amp;Stack{ Head: emptyNode, size: 0, } } Pushing onto and Popping off of the Stack #  Algorithms for pushing onto and popping off of the Stack, using a linked list.\nfunc (s *Stack) Push(d interface{}) *Stack { nextNode := \u0026amp;Node{ Next: nil, Data: d, } if s.Head.Data == nil { s.Head = nextNode s.size += 1 } else { s.Head.Next = s.Head s.Head = nextNode s.size += 1 } return s } func (s *Stack) Pop(v interface{}) *Stack { if s.IsEmpty() == true { fmt.Println(\u0026#34;Stack is empty\u0026#34;) return s } var node = s.Head s.Head = s.Head.Next s.size -= 1 return s } Links #  Code with the full program and helper methods below\nCode  "});index.add({'id':5,'href':'/docs/topic/python-data-structures/','title':"Python Data Structures",'section':"Topic",'content':"Python Data Structures #  Code and and an explanation of a Python Data Structure\n"});index.add({'id':6,'href':'/docs/topic/python-data-structures/queue/','title':"Queue",'section':"Python Data Structures",'content':"Python Data Structures #  Code and explanation for a Python Data Structure\nQueue #  First we look at the queue data structure. A queue is a simple list where we add to the back and remove from the front. Below is the class structure of the list in python, creating a Node - when initiated keeps track of it\u0026rsquo;s head, tail and the next element in the list.\nclass _Node: __slots__ = \u0026#39;_element\u0026#39;, \u0026#39;_next\u0026#39; # Constructor def __init__(self): self._head = None self.tail = None self._next = next Enqueue and Dequeue #  Algorithms for popping off the front and adding to the back, using a linked list.\ndef dequeue(self): if self.is_empty(): raiseEmpty(\u0026#39;Queue is empty\u0026#39;) answer = self._head._next self._size -= 1 if self.is_empty(): self._tail = None return answer def enqueue(self): newest = self._Node(e,None) if self.is_empty(): self._head = newest else: self._tail._next = newest self._tail = newest self._size += 1 Links #  Code with the full program and helper methods below\nCode  "});index.add({'id':7,'href':'/docs/topic/python-data-structures/stack/','title':"Stack",'section':"Python Data Structures",'content':"Python Data Structures #  Code and explanation for a Python Data Structure\nStack #  A stack is a fundamental data structure. It is used in the Operating System, memory is implemented as a stack. If we are able to visualize a stack, it will help us visualize some of the more complex ideas in computer science.\nBelow the python class structure for a Stack.\nclass Stack: class _Node: __slots__ = \u0026#39;element\u0026#39;, \u0026#39;next\u0026#39; def __init__(self,element, next): self._element = element self._next = next def __init__(self): self._head = None self._size = 0 Pushing onto and Popping off of the Stack #  Algorithms for pushing onto and popping off of the Stack, using a linked list.\ndef push(self,e): self._head = self._Node(e,self._head) self._size += 1 def pop(self): if self.is_empty(): raise Empty(\u0026#39;Stack is empty\u0026#39;) answer = self._head._element self._head = self._head._next self._size -= 1 return answer Links #  Code with the full program and helper methods below\nCode  "});})();